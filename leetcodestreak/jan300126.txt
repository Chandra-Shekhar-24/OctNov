Question ID: 2977
https://leetcode.com/problems/minimum-cost-to-convert-string-ii/description/?envType=daily-question&envId=2026-01-30

class TrieNode {
    TrieNode[] children = new TrieNode[26];
    int wordId = -1; // -1 means this is not a complete word
}

class Solution {
    private static final int INF = Integer.MAX_VALUE / 2;
    
    // Add a word to the trie and return its unique ID
    private int addWordToTrie(TrieNode root, String word, int[] nextId) {
        TrieNode currentNode = root;
        
        for (char letter : word.toCharArray()) {
            int index = letter - 'a';
            if (currentNode.children[index] == null) {
                currentNode.children[index] = new TrieNode();
            }
            currentNode = currentNode.children[index];
        }
        
        // Assign a new ID if this word hasn't been seen before
        if (currentNode.wordId == -1) {
            currentNode.wordId = ++nextId[0];
        }
        
        return currentNode.wordId;
    }
    
    public long minimumCost(
        String source,
        String target,
        String[] originalWords,
        String[] changedWords,
        int[] transformationCosts
    ) {
        int sourceLength = source.length();
        int wordCount = originalWords.length;
        
        // Create trie to store all words and map them to unique IDs
        TrieNode trieRoot = new TrieNode();
        int[] nextWordId = {-1}; // Start from -1, will increment to 0 for first word
        int totalWordIds = wordCount * 2; // Maximum possible unique words
        
        // Create graph for shortest path between words
        int[][] minCostBetweenWords = new int[totalWordIds][totalWordIds];
        for (int i = 0; i < totalWordIds; i++) {
            Arrays.fill(minCostBetweenWords[i], INF);
            minCostBetweenWords[i][i] = 0; // Cost to stay same word is 0
        }
        
        // Add all words to trie and build initial cost graph
        for (int i = 0; i < wordCount; i++) {
            int fromWordId = addWordToTrie(trieRoot, originalWords[i], nextWordId);
            int toWordId = addWordToTrie(trieRoot, changedWords[i], nextWordId);
            minCostBetweenWords[fromWordId][toWordId] = Math.min(
                minCostBetweenWords[fromWordId][toWordId], 
                transformationCosts[i]
            );
        }
        
        int uniqueWordCount = nextWordId[0] + 1; // Number of unique words found
        
        // Find cheapest paths between all words using Floyd-Warshall
        for (int intermediateWord = 0; intermediateWord < uniqueWordCount; intermediateWord++) {
            for (int fromWord = 0; fromWord < uniqueWordCount; fromWord++) {
                for (int toWord = 0; toWord < uniqueWordCount; toWord++) {
                    int directCost = minCostBetweenWords[fromWord][toWord];
                    int throughIntermediateCost = minCostBetweenWords[fromWord][intermediateWord] + 
                                                minCostBetweenWords[intermediateWord][toWord];
                    minCostBetweenWords[fromWord][toWord] = Math.min(directCost, throughIntermediateCost);
                }
            }
        }
        
        // DP array: minimum cost to transform first j characters
        long[] minCostToPosition = new long[sourceLength];
        Arrays.fill(minCostToPosition, -1); // -1 means impossible
        
        for (int endPosition = 0; endPosition < sourceLength; endPosition++) {
            // If previous position was impossible, skip
            if (endPosition > 0 && minCostToPosition[endPosition - 1] == -1) {
                continue;
            }
            
            long baseCost = (endPosition == 0) ? 0 : minCostToPosition[endPosition - 1];
            
            // Option 1: If characters match, no transformation needed
            if (source.charAt(endPosition) == target.charAt(endPosition)) {
                if (minCostToPosition[endPosition] == -1) {
                    minCostToPosition[endPosition] = baseCost;
                } else {
                    minCostToPosition[endPosition] = Math.min(minCostToPosition[endPosition], baseCost);
                }
            }
            
            // Option 2: Try transforming substring starting at current position
            TrieNode sourceNode = trieRoot;
            TrieNode targetNode = trieRoot;
            
            for (int startPosition = endPosition; startPosition < sourceLength; startPosition++) {
                char sourceChar = source.charAt(startPosition);
                char targetChar = target.charAt(startPosition);
                
                sourceNode = sourceNode.children[sourceChar - 'a'];
                targetNode = targetNode.children[targetChar - 'a'];
                
                // If either path doesn't exist, stop
                if (sourceNode == null || targetNode == null) {
                    break;
                }
                
                // If both are complete words and transformation is possible
                if (sourceNode.wordId != -1 && targetNode.wordId != -1 && 
                    minCostBetweenWords[sourceNode.wordId][targetNode.wordId] != INF) {
                    
                    long transformationCost = baseCost + minCostBetweenWords[sourceNode.wordId][targetNode.wordId];
                    
                    // Update DP for the end position of this transformation
                    if (minCostToPosition[startPosition] == -1 || 
                        transformationCost < minCostToPosition[startPosition]) {
                        minCostToPosition[startPosition] = transformationCost;
                    }
                }
            }
        }
        
        return minCostToPosition[sourceLength - 1];
    }
}



--------------------------------------------------------------------------------------------------
================================================================================
Algorithm Designer: Koushal Jha
Algorithm Name: Recursive Memoization with Substring Transformation
================================================================================

ALGORITHM EXPLANATION:
This recursive solution uses memoization (top-down dynamic programming) to find 
the minimum cost to transform the source string into the target string using 
allowed word transformations.

KEY STEPS:
1. PREPROCESSING:
   - Build a transformation map: Map<String, Map<String, Integer>>
   - Outer map key: Original word
   - Inner map: Changed word -> Minimum transformation cost
   - Store only the minimum cost for each (original, changed) pair

2. RECURSIVE FUNCTION (dfs):
   - Parameters: current position in string, source, target, transformation map, memo array
   
   a. BASE CASE:
      If position == source.length(), return 0 (no more characters to process)
   
   b. MEMOIZATION CHECK:
      If memo[position] != null, return memo[position] (already computed)
   
   c. INITIALIZE MINIMUM COST:
      Set minCost = Long.MAX_VALUE / 2 (a very large value)
   
   d. OPTION 1: CHARACTER MATCH
      If source.charAt(position) == target.charAt(position):
         minCost = Math.min(minCost, dfs(position + 1, ...))
   
   e. OPTION 2: SUBSTRING TRANSFORMATION
      For all possible substrings starting at current position:
        1. Extract substring from source (i to j)
        2. Extract substring from target (i to j)
        3. Check if transformation exists in map
        4. If exists: cost = transformationCost + dfs(j + 1, ...)
        5. Update minCost = Math.min(minCost, cost)
   
   f. CACHE AND RETURN:
      memo[position] = minCost
      return minCost

3. MAIN FUNCTION:
   - Build transformation map
   - Initialize memo array of size n+1
   - Call dfs(0, ...)
   - Return result (or -1 if impossible)

TIME COMPLEXITY: O(nÂ² * L) where n is string length, L is average word length
SPACE COMPLEXITY: O(n) for memoization cache

================================================================================
COMPLETE JAVA CODE:
================================================================================

import java.util.*;

class Solution {
    public long minimumCost(String source, String target, 
                           String[] originalWords, String[] changedWords, 
                           int[] transformationCosts) {
        // Step 1: Build transformation map with minimum costs
        Map<String, Map<String, Integer>> transformationMap = new HashMap<>();
        
        for (int i = 0; i < originalWords.length; i++) {
            String fromWord = originalWords[i];
            String toWord = changedWords[i];
            int cost = transformationCosts[i];
            
            transformationMap.putIfAbsent(fromWord, new HashMap<>());
            Map<String, Integer> innerMap = transformationMap.get(fromWord);
            
            // Store minimum cost for each transformation
            if (!innerMap.containsKey(toWord) || cost < innerMap.get(toWord)) {
                innerMap.put(toWord, cost);
            }
        }
        
        // Step 2: Initialize memoization array
        Long[] memo = new Long[source.length()];
        
        // Step 3: Start recursive search from position 0
        long result = dfs(0, source, target, transformationMap, memo);
        
        // Step 4: Return result (or -1 if impossible)
        return result >= Long.MAX_VALUE / 2 ? -1 : result;
    }
    
    private long dfs(int position, String source, String target,
                    Map<String, Map<String, Integer>> transformationMap,
                    Long[] memo) {
        // Base case: reached end of string
        if (position == source.length()) {
            return 0;
        }
        
        // Check memoization cache
        if (memo[position] != null) {
            return memo[position];
        }
        
        long minCost = Long.MAX_VALUE / 2;
        
        // Option 1: If characters match, move forward with no cost
        if (source.charAt(position) == target.charAt(position)) {
            minCost = Math.min(minCost, dfs(position + 1, source, target, transformationMap, memo));
        }
        
        // Option 2: Try all possible substring transformations
        StringBuilder sourceSubstring = new StringBuilder();
        StringBuilder targetSubstring = new StringBuilder();
        
        for (int end = position; end < source.length(); end++) {
            // Build substrings incrementally
            sourceSubstring.append(source.charAt(end));
            targetSubstring.append(target.charAt(end));
            
            String fromWord = sourceSubstring.toString();
            String toWord = targetSubstring.toString();
            
            // Check if this transformation is allowed
            if (transformationMap.containsKey(fromWord) && 
                transformationMap.get(fromWord).containsKey(toWord)) {
                
                int transformationCost = transformationMap.get(fromWord).get(toWord);
                long remainingCost = dfs(end + 1, source, target, transformationMap, memo);
                
                // Update minimum cost if valid
                if (remainingCost < Long.MAX_VALUE / 2) {
                    minCost = Math.min(minCost, transformationCost + remainingCost);
                }
            }
        }
        
        // Memoize and return result
        memo[position] = minCost;
        return minCost;
    }
}

================================================================================
EXAMPLE USAGE:
================================================================================

Input:
source = "abc"
target = "def"
originalWords = ["ab", "c"]
changedWords = ["de", "f"]
transformationCosts = [5, 3]

Execution:
1. Build map: {"ab" -> {"de": 5}, "c" -> {"f": 3}}
2. dfs(0):
   - Option 1: 'a' != 'd', so skip
   - Option 2: Try substrings:
     * "a"->"d": Not in map
     * "ab"->"de": Cost = 5 + dfs(2)
       dfs(2): 
         - Option 1: 'c' != 'f', skip
         - Option 2: "c"->"f": Cost = 3 + dfs(3)
           dfs(3): Base case, return 0
         Total: 5 + 3 = 8
3. Return 8

================================================================================
ADVANTAGES:
1. Easy to understand and implement
2. No need for complex graph algorithms
3. Naturally handles substring matching
4. Memoization prevents exponential time complexity

================================================================================
LIMITATIONS:
1. Slower than DP for large inputs
2. Can cause stack overflow for very long strings
3. Repeated substring creation can be optimized

================================================================================